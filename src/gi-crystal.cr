require "./gi-crystal/closure_data_manager"
require "./gi-crystal/toggle_ref_manager"

# This module have types, functions and macros used by the generated bindings, if you are just using the bindings you
# should never deal with any of this.
module GICrystal
  # A macro to check if a binding was generated and require it
  macro require(namespace, version)
    {% req_path = "#{__DIR__}/auto/#{namespace.underscore.id}-#{version.underscore.id}/#{namespace.underscore.id}.cr" %}
    {% unless file_exists?(req_path) %}
      {{ raise "Bindings for #{namespace.id}-#{version.id} not yet generated, run ./bin/gi-crystal first." }}
    {% end %}
    require {{ "gi-crystal/src/auto/#{namespace.underscore.id}-#{version.id}/#{namespace.underscore.id}" }}
  end

  # This annotation is used to identify types generated by the generator from user types.
  annotation GeneratedWrapper
  end

  # How the memory ownership is transfered (or not) from C to Crystal and vice-versa.
  enum Transfer
    # Transfer nothing from the callee (function or the type instance the property belongs to) to the caller.
    None
    # Transfer the container (list, array, hash table) from the callee to the caller.
    Container
    # Transfer everything, e.g. the container and its contents from the callee to the caller.
    Full
  end

  # See `declare_new_method`.
  INSTANCE_QDATA_KEY = LibGLib.g_quark_from_static_string("gi-crystal::instance")
  # See `declare_new_method`.
  INSTANCE_FACTORY = LibGLib.g_quark_from_static_string("gi-crystal::factory")

  # Raised when trying to cast an object that was already collected by GC.
  class ObjectCollectedError < RuntimeError
  end

  # :nodoc:
  def instance_pointer(object) : Pointer(Void)
    {% raise "Implement GICrystal.instance_pointer(object) for your fundamental type." %}
  end

  # :nodoc:
  def finalize_instance(object)
    {% raise "Implement GICrystal.finalize_instance(object) for your fundamental type." %}
  end

  # :nodoc:
  @[AlwaysInline]
  def to_bool(value : Int32) : Bool
    value != 0
  end

  # :nodoc:
  @[AlwaysInline]
  def to_c_bool(value : Bool) : Int32
    value ? 1 : 0
  end

  # This method must be implemented in bindings for all base types that have reference counting.
  @[AlwaysInline]
  def ref(null : Nil) : Nil
  end

  # :nodoc:
  def transfer_null_ended_array(ptr : Pointer(Pointer(UInt8)), transfer : Transfer) : Array(String)
    res = Array(String).new
    return res if ptr.null?

    item_ptr = ptr
    while !item_ptr.value.null?
      res << String.new(item_ptr.value)
      LibGLib.g_free(item_ptr.value) if transfer.full?
      item_ptr += 1
    end
    LibGLib.g_free(ptr) unless transfer.none?
    res
  end

  # :nodoc:
  def transfer_array(ptr : Pointer(Pointer(UInt8)), length : Int, transfer : Transfer) : Array(String)
    res = Array(String).new(length)
    return res if ptr.null?

    length.times do |i|
      item_ptr = (ptr + i).value
      res << String.new(item_ptr)
      LibGLib.g_free(item_ptr) if transfer.full?
    end
    LibGLib.g_free(ptr) unless transfer.none?
    res
  end

  # :nodoc:
  def transfer_array(ptr : Pointer(UInt8), length : Int, transfer : Transfer) : ::Bytes
    slice = ::Bytes.new(ptr, length, read_only: true)
    if transfer.full?
      slice = slice.clone
      LibGLib.g_free(ptr)
    end
    slice
  end

  # :nodoc:
  def transfer_array(ptr : Pointer(T), length : Int, transfer : Transfer) : Array(T) forall T
    Array(T).build(length) do |buffer|
      ptr.copy_to(buffer, length)
      length
    end
  ensure
    LibGLib.g_free(ptr) if transfer.full?
  end

  # :nodoc:
  def transfer_full(str : Pointer(UInt8)) : String
    String.new(str).tap do
      LibGLib.g_free(str)
    end
  end

  # This declare the `new` method on a instance of type *type*, *qdata_get_func* (g_object_get_qdata) is used
  # to fetch a possible already existing Crystal object.
  #
  # GICrystal stores the User defined Crystal objects instances in the GObject, so when it appears from C
  # world we can retrieve the Crystal instance back.
  #
  # This is mainly used for `GObject::Object`, since `GObject::ParamSpec` doesn't support casts on GICrystal.
  macro declare_new_method(type, qdata_get_func)
    # :nodoc:
    def self.new(pointer : Pointer(Void), transfer : GICrystal::Transfer) : self
      # Try to recover the Crystal instance if any
      instance = LibGObject.{{ qdata_get_func }}(pointer, GICrystal::INSTANCE_QDATA_KEY)
      return instance.as({{ type }}) if instance

      # Try to construct the right wrapper for the matching GObject using the function pointer
      # to `{{ type }}.new` stored in GType qdata.
      #
      # This pointer is stored at type initialization, i.e. the `g_type` class method.
      instance_g_type = pointer.as(LibGObject::TypeInstance*).value.g_class.value.g_type
      if instance_g_type != g_type
        ctor_ptr = LibGObject.g_type_get_qdata(instance_g_type, GICrystal::INSTANCE_FACTORY)
        if ctor_ptr
          ctor = Proc(Void*, GICrystal::Transfer, {{ type }}).new(ctor_ptr, Pointer(Void).null)
          return ctor.call(pointer, transfer)
        end
      end

      # This object never meet Crystal land and there's no Crystal wrapper for the exact GType,
      # so we allocate memory and initialize it for the type we know.
      instance = {{ type }}.allocate
      instance.initialize(pointer, transfer)
      GC.add_finalizer(instance)
      instance
    end
  end

  extend self
end
