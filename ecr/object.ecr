<%= require_file(object.parent) -%>
<% object.interfaces.each do |interface| -%>
  <%= require_file(interface) %>
<% end %>

module <%= namespace_name %>
  <% render_doc(object) -%>
  @[GObject::GeneratedWrapper]
  class <%= type_name %> <%= parent_class %>
    <% object.interfaces.each do |interface| -%>
    include <%= to_crystal_type(interface, namespace != interface.namespace) %>
    <% end %>

    @pointer : Pointer(Void)

    <% if object.class_struct.nil? || g_object_type? # This is just to avoid render a empty macro block %>
    macro inherited
    <% if object.class_struct.nil? %>
    {{ raise "Cannot inherit from #{@type.superclass}" unless @type.annotation(GObject::GeneratedWrapper) }}
    <% elsif g_object_type? %>
      {% unless @type.annotation(GObject::GeneratedWrapper) %}
      # Cast a `GObject::Object` to this type, returns nil if cast can't be made.
      def self.cast?(obj : GObject::Object) : self?
        return if LibGObject.g_type_check_instance_is_a(obj, g_type).zero?

        # If the object was collected by Crystal GC but still alive in C world we can't bring
        # the crystal object form the dead.
        gc_collected = LibGObject.<%= object.qdata_get_func %>(obj, GICrystal::GC_COLLECTED_QDATA_KEY)
        instance = LibGObject.<%= object.qdata_get_func %>(obj, GICrystal::INSTANCE_QDATA_KEY)
        raise GICrystal::ObjectCollectedError.new if gc_collected || instance.null?

        instance.as(self)
      end
      {% end %}
    <% end %>
    end
    <% end %>

    <% class_struct = object.class_struct -%>
    <% if class_struct %>
    # :nodoc:
    def self._register_derived_type(klass : Class, class_init, instance_init)
      LibGObject.g_type_register_static_simple(g_type, klass.name,
                                               sizeof(<%= to_lib_type(class_struct) %>), class_init,
                                               sizeof(<%= to_lib_type(object) %>), instance_init, 0)
    end
    <% end %>

    GICrystal.define_new_method(<%= type_name %>, <%= object.qdata_get_func %>, <%= object.qdata_set_func %>)

    # Initialize a new `<%= type_name %>`.
    def initialize
      @pointer = LibGObject.g_object_newv(self.class.g_type, 0, Pointer(Void).null)
      LibGObject.g_object_ref_sink(self) if LibGObject.g_object_is_floating(self) == 1
      LibGObject.g_object_set_qdata(self, GICrystal::INSTANCE_QDATA_KEY, Pointer(Void).new(object_id))
    end

    # :nodoc:
    def initialize(@pointer, transfer : GICrystal::Transfer)
      <% if object.parent.nil? %>
        <% if g_object_type? %>
          LibGObject.<%= object.ref_function %>(self) if transfer.none? || LibGObject.g_object_is_floating(self) == 1
        <% else %>
          LibGObject.<%= object.ref_function %>(self) if transfer.none?
        <% end %>
      <% else %>
        super
      <% end %>
    end

    <% if all_properties.any? -%>
      <% render "ecr/gobject_constructor.ecr" %>
    <% end %>

    <% if object.parent.nil? %>

      # Called by the garbage collector. Decreases the reference count of object.
      # (i.e. its memory is freed).
      def finalize
        {% if flag?(:debugmemory) %}
        LibC.printf("~%s at %p - ref count: %d\n", self.class.name.to_unsafe, self, ref_count)
        {% end %}
        LibGObject.<%= object.qdata_set_func %>(self, GICrystal::INSTANCE_QDATA_KEY, Pointer(Void).null)
        LibGObject.<%= object.qdata_set_func %>(self, GICrystal::GC_COLLECTED_QDATA_KEY, Pointer(Void).new(0x1))
        LibGObject.<%= object.unref_function %>(self)
      end

      # Returns a pointer to the C object.
      def to_unsafe
        @pointer
      end

      <% render "ecr/cast_methods.ecr" %>
      <% render "ecr/ref_count_method.ecr" %>
    <% end %>

    <% render "ecr/g_type_method.ecr" %>
    <% render_properties %>
    <% render_methods %>
    <% render_signals %>
  end
end
