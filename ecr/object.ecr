<%= require_file(object.parent) -%>
<% object.interfaces.each do |interface| -%>
  <%= require_file(interface) %>
<% end %>

module <%= namespace_name %>
  <% if g_object_type? %>
  # :nodoc:
  annotation GeneratedWrapper
    # This annotation is used to identify user types that inherit from GObject from binding types that does the same.
  end
  <% end %>

  <% render_doc(object) -%>
  @[GObject::GeneratedWrapper]
  class <%= type_name %> <%= parent_class %>
    <% object.interfaces.each do |interface| -%>
    include <%= to_crystal_type(interface, namespace != interface.namespace) %>
    <% end %>

    @pointer : Pointer(Void)


  <% if g_object_type? %>
    # Declares a GObject signal.
    #
    # Supported signal parameter types are:
    #
    #  - Integer types
    #  - Float types
    macro signal(signature)
      {%
      raise "signal parameter must be a signature (Macros::Call), got #{signature.class_name}" unless signature.is_a?(Call)
      raise "Signal signature #{signature} can't have a receiver" if signature.receiver
      raise "Signal signature #{signature} can't have a block argument" if signature.block_arg
      %}

      struct {{ signature.name.titleize }}Signal < GObject::Signal
        def name : String
          @detail ? "{{ signature.name }}::#{@detail}" : {{ signature.name.stringify }}
        end

        alias LeanProc = Proc({{ (signature.args.map(&.type) << Nil).splat }})

        def connect(*, after : Bool = false, &block : LeanProc) : GObject::SignalConnection
          connect(block, after: after)
        end

        def connect(handler : LeanProc, *, after : Bool = false) : GObject::SignalConnection
          _box = ::Box.box(handler)
          {% if signature.args.empty? %}
          handler = ->(_lib_sender : Pointer(Void), _lib_box : Pointer(Void)) { ::Box(LeanProc).unbox(_lib_box).call }.pointer
          {% else %}
          handler = ->(_lib_sender : Pointer(Void),
          {% for arg in signature.args %}
          {%
            resolved_type = arg.type.resolve
            if resolved_type == String
              type = ::Pointer(UInt8)
            elsif resolved_type == Bool
              type = ::Int32
            else
              type = arg.type
            end
          %}
          {{ arg.var }} : {{ type }},
          {% end %}
          _lib_box : Pointer(Void)) {

            {% for arg in signature.args %}
            {% resolved_type = arg.type.resolve %}
            {% if arg.type.resolve == String %}
              {{ arg.var }} = String.new({{ arg.var }})
            {% elsif arg.type.resolve == Bool %}
              {{ arg.var }} = {{ arg.var }} != 0
            {% end %}
            {% end %}

            ::Box(LeanProc).unbox(_lib_box).call({{ signature.args.map(&.var).splat }})
          }.pointer
          {% end %}

          handler = LibGObject.g_signal_connect_data(@source, name, handler,
            GICrystal::ClosureDataManager.register(_box), ->GICrystal::ClosureDataManager.deregister, after.to_unsafe)
          GObject::SignalConnection.new(@source, handler)
        end

        def emit({{ signature.args.splat }})
          LibGObject.g_signal_emit_by_name(@source, {{ signature.name.stringify }}, {{ signature.args.map(&.var).splat }})
        end
      end

      def {{ signature.name }}_signal
        {{ signature.name.titleize }}Signal.new(self)
      end

      def self._class_init(klass : Pointer(LibGObject::TypeClass), user_data : Pointer(Void)) : Nil
        LibGObject.g_signal_new({{ signature.name.stringify }}, g_type,
        GObject::SignalFlags.flags(RunLast, NoRecurse, NoHooks),
        0,                   # class_offset
        Pointer(Void).null,  # accumulator
        Pointer(Void).null,  # accumulator_data
        Pointer(Void).null,  # marshaller
        GObject::TYPE_NONE,  # return_type
        {{ signature.args.size }}, # n_params
        {% for arg in signature.args %}
        {{ arg.type }}.g_type,
        {% end %}
        Pointer(Void).null)
        previous_def
      end
    end
  <% end %>

    macro inherited
    <% if object.class_struct.nil? %>
    {{ raise "Cannot inherit from #{@type.superclass}" unless @type.annotation(GObject::GeneratedWrapper) }}
    <% elsif g_object_type? %>
      {% unless @type.annotation(GObject::GeneratedWrapper) %}
      # GType for the new created type
      @@_g_type : UInt64 = 0

      def self.g_type : UInt64
        if LibGLib.g_once_init_enter(pointerof(@@_g_type)) != 0
          g_type = {{ @type.superclass.id }}._register_derived_type({{ @type.id }},
            ->_class_init(Pointer(LibGObject::TypeClass), Pointer(Void)),
            ->_instance_init(Pointer(LibGObject::TypeInstance), Pointer(LibGObject::TypeClass)))

          LibGLib.g_once_init_leave(pointerof(@@_g_type), g_type)
        end

        @@_g_type
      end

      # :nodoc:
      def self._class_init(klass : Pointer(LibGObject::TypeClass), user_data : Pointer(Void)) : Nil
      end

      # :nodoc:
      def self._instance_init(instance : Pointer(LibGObject::TypeInstance), type : Pointer(LibGObject::TypeClass)) : Nil
      end

      # Cast a `GObject::Object` to this type, returns nil if cast can't be made.
      def self.cast?(obj : GObject::Object) : self?
        return if LibGObject.g_type_check_instance_is_a(obj, g_type).zero?

        # If the object was collected by Crystal GC but still alive in C world we can't bring
        # the crystal object form the dead.
        gc_collected = LibGObject.<%= object.qdata_get_func %>(obj, GICrystal::GC_COLLECTED_QDATA_KEY)
        instance = LibGObject.<%= object.qdata_get_func %>(obj, GICrystal::INSTANCE_QDATA_KEY)
        raise GICrystal::ObjectCollectedError.new if gc_collected || instance.null?

        instance.as(self)
      end
      {% end %}
    <% end %>
    <% unless object.class_struct.nil? %>
      macro method_added(method)
        {% verbatim do %}
        <% object.class_struct.try &.fields.each do |field| -%>
          <% next unless field.type_info.tag.interface? -%>
          <% next unless interface = field.type_info.interface.as?(CallbackInfo) -%>
          <% next if interface.args.empty? %>
          {% if method.name == "<%= field.name %>" %}
            def self._vfunc_<%= field.name %>(<%= interface.args.map { |arg| "#{arg.name} : #{to_crystal_type(arg.type_info, include_namespace: true)}" }.join(", ") %>) : <%= to_crystal_type(interface.return_type) %>
              <%= interface.args.first.name %>.unsafe_as(self).<%= field.name %>(<%= interface.args[1..].map(&.name).join(", ") %>)
            end

            def self._class_init(klass : Pointer(LibGObject::TypeClass), user_data : Pointer(Void)) : Nil
              vfunc_ptr = (klass.as(Pointer(Void)) + <%= field.byteoffset %>).as(Pointer(Pointer(Void)))
              vfunc_ptr.value = (->_vfunc_<%= field.name %>(<%= interface.args.map { |arg| to_crystal_type(arg.type_info, include_namespace: true) }.join(", ") %>)).pointer
              previous_def
            end
          {% end %}
        <% end %>
        {% end %}
      end
    <% end %>
    end

    <% class_struct = object.class_struct -%>
    <% if class_struct %>
    # :nodoc:
    def self._register_derived_type(klass : Class, class_init, instance_init)
      LibGObject.g_type_register_static_simple(g_type, klass.name,
                                               sizeof(<%= to_lib_type(class_struct) %>), class_init,
                                               sizeof(<%= to_lib_type(object) %>), instance_init, 0)
    end
    <% end %>

    GICrystal.define_new_method(<%= type_name %>, <%= object.qdata_get_func %>, <%= object.qdata_set_func %>)

    # Initialize a new `<%= type_name %>`.
    def initialize
      @pointer = LibGObject.g_object_newv(self.class.g_type, 0, Pointer(Void).null)
      LibGObject.g_object_ref_sink(self) if LibGObject.g_object_is_floating(self) == 1
      LibGObject.g_object_set_qdata(self, GICrystal::INSTANCE_QDATA_KEY, Pointer(Void).new(object_id))
    end

    # :nodoc:
    def initialize(@pointer, transfer : GICrystal::Transfer)
      <% if object.parent.nil? %>
        <% if g_object_type? %>
          LibGObject.<%= object.ref_function %>(self) if transfer.none? || LibGObject.g_object_is_floating(self) == 1
        <% else %>
          LibGObject.<%= object.ref_function %>(self) if transfer.none?
        <% end %>
      <% else %>
        super
      <% end %>
    end

    <% if all_properties.any? -%>
      <% render "ecr/gobject_constructor.ecr" %>
    <% end %>

    <% if object.parent.nil? %>

      # Called by the garbage collector. Decreases the reference count of object.
      # (i.e. its memory is freed).
      def finalize
        {% if flag?(:debugmemory) %}
        LibC.printf("~%s at %p - ref count: %d\n", self.class.name.to_unsafe, self, ref_count)
        {% end %}
        LibGObject.<%= object.qdata_set_func %>(self, GICrystal::INSTANCE_QDATA_KEY, Pointer(Void).null)
        LibGObject.<%= object.qdata_set_func %>(self, GICrystal::GC_COLLECTED_QDATA_KEY, Pointer(Void).new(0x1))
        LibGObject.<%= object.unref_function %>(self)
      end

      # Returns a pointer to the C object.
      def to_unsafe
        @pointer
      end

      <% render "ecr/cast_methods.ecr" %>
      <% render "ecr/ref_count_method.ecr" %>
    <% end %>

    <% render "ecr/g_type_method.ecr" %>
    <% render_properties %>
    <% render_methods %>
    <% render_signals %>
  end
end
